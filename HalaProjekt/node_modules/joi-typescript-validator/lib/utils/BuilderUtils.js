"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Validate = exports.getSchemaDescription = exports.getSchema = void 0;
const joi_1 = __importDefault(require("joi"));
const date_1 = __importDefault(require("@joi/date"));
const MetadataHelpers_1 = require("./MetadataHelpers");
/**
 * Joi instance customized with JoiDateFactory extension
 */
const Joi = joi_1.default.extend(date_1.default);
/**
 * Map of saved schemas for faster access internally.
 * Prevents regenerating schemas that have already been generated
 * @type {Map<Class<unknown>, BaseJoi.Schema>}
 */
const savedSchemas = new Map();
/**
 * Build string field Joi schema
 * @param {FieldDescription} description Field description object
 * @returns {BaseJoi.StringSchema}
 */
function buildJoiString(description) {
    let schema = Joi.string();
    if (description.minLength || description.nonempty) {
        schema = schema.min(Math.max(description.minLength || 0, 1));
    }
    if (description.maxLength) {
        schema = schema.max(description.maxLength);
    }
    if (description.email) {
        schema = schema.email();
    }
    return schema;
}
/**
 * Build date field Joi schema
 * @param {FieldDescription} description Field description object
 * @returns {BaseJoi.DateSchema}
 */
function buildJoiDate(description) {
    let schema = Joi.date();
    if (description.dateString && description.dateStringFormat) {
        schema = schema.format(description.dateStringFormat);
    }
    return schema;
}
/**
 * Build number field Joi schema
 * @param {FieldDescription} description Field description object
 * @returns {BaseJoi.NumberSchema}
 */
function buildJoiNumber(description) {
    let schema = Joi.number();
    if (description.minValue) {
        schema = schema.min(description.minValue.value);
        if (description.minValue.exclude) {
            schema = schema.invalid(description.minValue.value);
        }
    }
    if (description.maxValue) {
        schema = schema.max(description.maxValue.value);
        if (description.maxValue.exclude) {
            schema = schema.invalid(description.maxValue.value);
        }
    }
    if (description.positive) {
        schema = schema.positive();
    }
    if (description.negative) {
        schema = schema.negative();
    }
    return schema;
}
/**
 * Build array field Joi schema
 * @param {FieldDescription} description Field description object
 * @returns {BaseJoi.ArraySchema}
 */
function buildJoiArray(description) {
    let schema = Joi.array();
    if (description.typeInfo) {
        schema = schema.items(buildJoiChildren({ designType: description.typeInfo }));
    }
    else {
        schema = schema.items(Joi.any());
    }
    if (description.minLength || description.nonempty) {
        schema = schema.min(Math.max(description.minLength || 0, 1));
    }
    if (description.maxLength) {
        schema = schema.max(description.maxLength);
    }
    return schema;
}
/**
 * Build non-primitive object field Joi schema
 * @param {FieldDescription} description Field description object
 * @returns {BaseJoi.ObjectSchema}
 */
function buildJoiObject(description) {
    const metadata = (0, MetadataHelpers_1.getMetadata)(description.designType);
    if (!metadata) {
        return Joi.any();
    }
    const payload = Object.keys(metadata).reduce((acc, item) => (Object.assign(Object.assign({}, acc), { [item]: buildJoiChildren(metadata[item]) })), {});
    const schema = Joi.object().keys(payload);
    const options = (0, MetadataHelpers_1.getOptions)(description.designType);
    return options ? schema.options(options) : schema;
}
/**
 * Extend field Joi schema with global conditions
 * @param {BaseJoi.Schema}   fieldSchema Field Joi schema
 * @param {FieldDescription} description Field description object
 * @returns {BaseJoi.Schema}
 */
function buildJoiGlobals(fieldSchema, description) {
    let schema = fieldSchema;
    if (description.nullable) {
        schema = schema.allow(null);
    }
    if (description.options) {
        schema = schema.valid(...description.options);
    }
    if (description.required) {
        schema = schema.required();
    }
    else {
        schema = schema.optional();
    }
    if (description.customSchema) {
        if (typeof description.customSchema === "function") {
            schema = description.customSchema(schema);
        }
        else {
            schema = description.customSchema;
        }
    }
    const globals = (0, MetadataHelpers_1.getGlobalArgs)(description.designType);
    if (globals) {
        if (typeof globals === "function") {
            schema = globals(schema);
        }
        else {
            schema = globals;
        }
    }
    return schema;
}
/**
 * Build field schema depending on type
 * @param {FieldDescription} description Field description object
 * @returns {BaseJoi.Schema}
 */
function buildFieldSchema(description) {
    var _a;
    const designType = description.dateString ? "Date" : (_a = description.designType) === null || _a === void 0 ? void 0 : _a.name;
    switch (designType) {
        case "Array":
            return buildJoiArray(description);
        case "Date":
            return buildJoiDate(description);
        case "Boolean":
            return Joi.boolean();
        case "Number":
            return buildJoiNumber(description);
        case "String":
            return buildJoiString(description);
        default:
            return buildJoiObject(description);
    }
}
/**
 * Build field schema with global conditions
 * @param {FieldDescription} description Field description object
 */
function buildJoiChildren(description) {
    return buildJoiGlobals(buildFieldSchema(description), description);
}
/**
 * Build Joi schema for given class
 * @template T
 * @param {Class<T>} klass Class, for which, to generate the Joi schema
 * @returns {BaseJoi.ObjectSchema}
 */
function buildJoiRoot(klass) {
    const metadata = (0, MetadataHelpers_1.getMetadata)(klass) || {};
    const partialSchema = Object.keys(metadata).reduce((acc, item) => (Object.assign(Object.assign({}, acc), { [item]: buildJoiChildren(metadata[item]) })), {});
    const options = (0, MetadataHelpers_1.getOptions)(klass);
    const globals = (0, MetadataHelpers_1.getGlobalArgs)(klass);
    const objectSchema = joi_1.default.object().keys(partialSchema);
    const schema = options ? objectSchema.options(options) : objectSchema;
    if (globals) {
        if (typeof globals === "function") {
            return globals(schema);
        }
        return globals;
    }
    return schema;
}
/**
 * Returns Joi schema for the given class
 * @template T
 * @param {Class<T>} klass             Class for which to get or build the schema
 * @param {boolean}  [shouldSave=true] Boolean flag to choose whether or not to save the schema
 * @returns {BaseJoi.Schema} Joi Schema
 */
function getSchema(klass, shouldSave = true) {
    const schema = savedSchemas.get(klass) || buildJoiRoot(klass);
    if (shouldSave) {
        savedSchemas.set(klass, schema);
    }
    return schema;
}
exports.getSchema = getSchema;
/**
 * Returns a plain object representing the schema's rules and properties for the given class
 * @template T
 * @param {Class<T>} klass             Class for which to get the schema's rules and properties
 * @param {boolean}  [shouldSave=true] Boolean flag to choose whether or not to save the schema
 * @returns {BaseJoi.Description} Joi schema's rules and properties
 */
function getSchemaDescription(klass, shouldSave = true) {
    return getSchema(klass, shouldSave).describe();
}
exports.getSchemaDescription = getSchemaDescription;
/**
 * Validates the class instance object and returns Joi validation result
 * @template T
 * @param {Class<T>} klass             Class of object
 * @param {object}   instance          Class instance object
 * @param {boolean}  [shouldSave=true] Boolean flag to choose whether or not to save the schema
 * @returns {BaseJoi.ValidationResult} Joi ValidationResult
 */
function Validate(klass, instance, shouldSave = true) {
    return getSchema(klass, shouldSave).validate(instance);
}
exports.Validate = Validate;
