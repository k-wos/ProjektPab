"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.SchemaOptions = exports.CustomSchema = exports.DateString = exports.Email = exports.ValidOptions = exports.MinLength = exports.MaxLength = exports.NotEmpty = exports.Negative = exports.Positive = exports.Min = exports.Max = exports.ItemType = exports.Nullable = exports.Optional = exports.Required = exports.ClassDescription = exports.MetadataKeys = void 0;
require("reflect-metadata");
/**
 * MetadataKeys constant object containing Reflect metadata keys
 */
exports.MetadataKeys = { Fields: "validate:fields" };
/**
 * Class description metadata
 */
class ClassDescription {
}
exports.ClassDescription = ClassDescription;
/**
 * Attach field design type and description to class prototype metadata
 * @template T
 * @param {T}                target      Class prototype to attach field design type and description to
 * @param {string}           propertyKey Field key to identify the field, for which, to set the description and design type
 * @param {FieldDescription} description Field description metadata to attach to class prototype
 */
function setFieldDescription(target, propertyKey, description) {
    const designType = Reflect.getMetadata("design:type", target, propertyKey);
    const metadata = getFieldsMetadata(target);
    const classDescription = metadata.get(target.constructor) || {};
    const fields = classDescription.fields || {};
    fields[propertyKey] = fields[propertyKey] || {};
    fields[propertyKey] = Object.assign(Object.assign(Object.assign({}, fields[propertyKey]), { designType }), description);
    metadata.set(target.constructor, Object.assign(Object.assign({}, classDescription), { fields }));
    Reflect.defineMetadata(exports.MetadataKeys.Fields, metadata, target);
}
/**
 * Attach Joi schema or schema function to class metadata as globalArgs
 * @template T
 * @param {Class<T>}   klass Class to attach globalArgs to
 * @param {SchemaArgs} args  Joi schema or schema function to attach to class
 */
function setSchemaGlobals(klass, args) {
    const metadata = getFieldsMetadata(klass.prototype);
    const classDescription = metadata.get(klass) || {};
    metadata.set(klass, Object.assign(Object.assign({}, classDescription), { globalArgs: args }));
    Reflect.defineMetadata(exports.MetadataKeys.Fields, metadata, klass);
}
/**
 * Attach Joi validation options to class metadata as options
 * @template T
 * @param {Class<T>}          klass   Class to attach validations options to
 * @param {ValidationOptions} options Validations options to attach to class
 */
function setSchemaOptions(klass, options) {
    const metadata = getFieldsMetadata(klass.prototype);
    const classDescription = metadata.get(klass) || {};
    metadata.set(klass, Object.assign(Object.assign({}, classDescription), { options }));
    Reflect.defineMetadata(exports.MetadataKeys.Fields, metadata, klass);
}
/**
 * Get fields metadata Map for class prototype
 * @template T
 * @param {T} target Class prototype
 * @returns {TreeMetadata} Existing fields metadata or a new empty Map
 */
function getFieldsMetadata(target) {
    const reflectMetadata = Reflect.getMetadata(exports.MetadataKeys.Fields, target);
    return reflectMetadata || new Map();
}
/**
 * Mark field value as required
 * @template T
 */
function Required() {
    return (target, propertyKey) => {
        const description = { required: true };
        setFieldDescription(target, propertyKey, description);
    };
}
exports.Required = Required;
/**
 * Mark field value as optional
 * @template T
 */
function Optional() {
    return (target, propertyKey) => {
        const description = { required: false };
        setFieldDescription(target, propertyKey, description);
    };
}
exports.Optional = Optional;
/**
 * Mark field value as nullable
 * @template T
 * @param {boolean} [isEnabled=true] Flag used to overwrite decorator on parent class field
 */
function Nullable(isEnabled = true) {
    return (target, propertyKey) => {
        const description = { nullable: isEnabled };
        setFieldDescription(target, propertyKey, description);
    };
}
exports.Nullable = Nullable;
/**
 * Overwrite automatic field type with the given value
 * @template T
 * @template I
 * @param {Class<I>} type Primitive or class value to set the field type to
 */
function ItemType(type) {
    return (target, propertyKey) => {
        const description = { typeInfo: type };
        setFieldDescription(target, propertyKey, description);
    };
}
exports.ItemType = ItemType;
/**
 * Constrain number field to be less than or equal to a certain value
 * @template T
 * @param {Threshold | number} value Value, by which, to constrain the field to be less than or equal to
 */
function Max(value) {
    const maxValue = typeof (value) === "number" ? { value } : value;
    return (target, propertyKey) => {
        const description = { maxValue };
        setFieldDescription(target, propertyKey, description);
    };
}
exports.Max = Max;
/**
 * Constrain number field to be greater than or equal to a certain value
 * @template T
 * @param {Threshold | number} value Value, by which, to constrain the field to be greater than or equal to
 */
function Min(value) {
    const minValue = typeof (value) === "number" ? { value } : value;
    return (target, propertyKey) => {
        const description = { minValue };
        setFieldDescription(target, propertyKey, description);
    };
}
exports.Min = Min;
/**
 * Constrain number field to be a positive number (greater than 0)
 * @template T
 * @param {boolean} [isEnabled=true] Flag used to overwrite decorator on parent class field
 */
function Positive(isEnabled = true) {
    return (target, propertyKey) => {
        const description = { positive: isEnabled };
        setFieldDescription(target, propertyKey, description);
    };
}
exports.Positive = Positive;
/**
 * Constrain number field to be a negative number (less than 0)
 * @template T
 * @param {boolean} [isEnabled=true] Flag used to overwrite decorator on parent class field
 */
function Negative(isEnabled = true) {
    return (target, propertyKey) => {
        const description = { negative: isEnabled };
        setFieldDescription(target, propertyKey, description);
    };
}
exports.Negative = Negative;
/**
 * Constrain array or string field length to be greater than 0
 * @template T
 * @param {boolean} [isEnabled=true] Flag used to overwrite decorator on parent class field
 */
function NotEmpty(isEnabled = true) {
    return (target, propertyKey) => {
        const description = { nonempty: isEnabled };
        setFieldDescription(target, propertyKey, description);
    };
}
exports.NotEmpty = NotEmpty;
/**
 * Constrain array or string field to have a maximum length
 * @template T
 * @param {number} value Value, by which, to constrain the maximum length
 */
function MaxLength(value) {
    return (target, propertyKey) => {
        const description = { maxLength: value };
        setFieldDescription(target, propertyKey, description);
    };
}
exports.MaxLength = MaxLength;
/**
 * Constrain array or string field to have a minimum length
 * @template T
 * @param {number} value Value, by which, to constrain the minimum length
 */
function MinLength(value) {
    return (target, propertyKey) => {
        const description = { minLength: value };
        setFieldDescription(target, propertyKey, description);
    };
}
exports.MinLength = MinLength;
/**
 * Constrain field to only the allowed values passed
 * @template T
 * @param {unknown[]} args Values, by which, to constrain the field
 */
function ValidOptions(...args) {
    return (target, propertyKey) => {
        const description = { options: args };
        setFieldDescription(target, propertyKey, description);
    };
}
exports.ValidOptions = ValidOptions;
/**
 * Constrain field value to be of email format
 * @template T
 * @param {boolean} [isEnabled=true] Flag used to overwrite decorator on parent class field
 */
function Email(isEnabled = true) {
    return (target, propertyKey) => {
        const description = { email: isEnabled };
        setFieldDescription(target, propertyKey, description);
    };
}
exports.Email = Email;
/**
 * Constrain date or string field to be of a given format
 * @template T
 * @param {string} [format="YYYY-MM-DD"] Format, by which, to constrain the field
 */
function DateString(format = "YYYY-MM-DD") {
    return (target, propertyKey) => {
        const description = { dateString: true, dateStringFormat: format };
        setFieldDescription(target, propertyKey, description);
    };
}
exports.DateString = DateString;
/**
 * Constrain field or entire class fields by the Joi schema or schema function passed
 * @template T
 * @param {SchemaArgs} schema Joi schema or schema fuction, by which, to constrain field or class
 */
function CustomSchema(schema) {
    return (target, propertyKey) => {
        if (propertyKey) {
            const description = { customSchema: schema };
            setFieldDescription(target, propertyKey, description);
        }
        else {
            setSchemaGlobals(target, schema);
        }
    };
}
exports.CustomSchema = CustomSchema;
/**
 * Set class schema options, to be used when generating validations
 * @template T
 * @param {ValidationOptions} options Validation options
 */
function SchemaOptions(options) {
    return (target) => {
        setSchemaOptions(target, options);
    };
}
exports.SchemaOptions = SchemaOptions;
